<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>xwMOOC: </title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="http://statkclee.github.io/swcarpentry-version-5-3-new/css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="http://statkclee.github.io/swcarpentry-version-5-3-new/css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="http://statkclee.github.io/swcarpentry-version-5-3-new/css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="http://statkclee.github.io/swcarpentry-version-5-3-new/img/software-carpentry-banner.png" />
      <!--     <img alt="xwMOOC banner" src="img/xwMOOC.png" />
       -->  </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
          <h1 class="title"></h1>
          
<h2 id="기후-데이터-작업">기후 데이터 작업</h2>
<h4 id="목표">목표</h4>
<ul>
<li>간단한 REST API를 활용해서 데이터셋을 다운로드하는 파이썬 프로그램을 작성한다.</li>
<li>CSV가 무엇인지 설명하고 CSV 데이터셋을 읽는다.</li>
</ul>
<h3 id="단계-데이터-찾기">1 단계: 데이터 찾기</h3>
<p>점점 더 많은 조직에서 <a href="../../gloss.html#rest">REST</a>(REpresentational State Transfer)로 불리는 형식으로 웹상에 데이터셋을 공개한다. REST의 상세한 사항(그리고 사항)이 중요한 것은 아니다; 중요하는 것은 REST가 언제 사용되고, 모든 데이터셋이 URL로 식별된다는 것이다.</p>
<p>예제로 세계은행 <a href="http://data.worldbank.org/developers/climate-data-api">기후 데이터 API(Climate Data API)</a>로 제공되는 15개 지구순환모델로 생성되는 데이터를 사용한다. API 홈페이지에 따르면, 다양한 값에 대한 연평균치를 담고 있는 데이터셋은 URL 형태로 식별된다.</p>
<pre>
http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/<em><strong>var</strong></em>/year/<em><strong>iso3</strong></em>.<em><strong>ext</strong></em>
</pre>
<p>각 요소는 다음과 같다.:</p>
<ul>
<li><em><strong>var</strong></em>는 <code>pr</code> (강수량) 혹은 <code>tas</code> (“지표면 온도”)다;</li>
<li><em><strong>iso3</strong></em> 국제표준기구(International Standards Organization, ISO)가 정한 <a href="http://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">국가별 3-문자 코드</a>다. 예를 들어 “CAN”은 캐나다, “BRA”는 브라질이다.</li>
<li><em><strong>ext</strong></em> (확장 “extension” 줄임말)은 다운로드받을 데이터 형식을 지정한다. 형식에 대한 몇가지 선택지가 있지만, 가장 간단한 것이 <a href="../../gloss.html#csv">CSV(comma-separated values,콤마구분값)</a>로, 각 레코드는 행이고, 각 행 값은 콤마로 구분된다. (CSV는 스프레드쉬트 데이터에 자주 사용된다.)</li>
</ul>
<p>예를 들어, 캐나다 연평균기온을 CSV 파일형식으로 원한다면, URL은 다음과 같다:</p>
<pre>
http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.
csv
</pre>
<p>상기 URL을 웹브라우져에 붙여넣고 엔터를 치면, 다음이 화면에 출력된다.</p>
<pre><code>year,data
1901,-7.67241907119751
1902,-7.862711429595947
1903,-7.910782814025879
...
2007,-6.819293975830078
2008,-7.2008957862854
2009,-6.997011661529541</code></pre>
<blockquote>
<h4>무대 뒤에서(Behind the Scenes)</h4>
<p>상기 특정 데이터셋은 서버에 파일형태로 저장될 수도 있고, 서버가 다음을 수행할 수도 있다:</p>
<ol style="list-style-type: decimal">
<li>사용자가 입력한 URL을 받는다.</li>
<li>URL을 조각으로 나눈다.</li>
<li>3개 핵심 필드를 추출한다.(변수(var), iso3(국가코드), ext(파일형식)).</li>
<li>데이터베이스에서 요청 데이터를 가져온다.</li>
<li>데이터를 CSV 형식으로 저장한다.</li>
<li>작업결과를 웹브라우져에 전송한다.</li>
</ol>
<p>세계은행(World Bank)이 URL을 변경하지 않는다면, 프로그램을 변경하지 않고 원하는 데이터를 조건만 변경하여 다운로드할 수 있다.</p>
</blockquote>
<h4 id="도전-과제">도전 과제</h4>
<ol style="list-style-type: decimal">
<li>기후자료API(Climate Data API)에 대한 <a href="http://data.worldbank.org/developers/climate-data-api">문서(documentation)</a>를 읽고나서, 1980년에서 1999년까지 아프카니스탄(Afghanistan) 평균온도를 검색하는 URL을 작성하세요.</li>
</ol>
<h3 id="단계-데이터-가져오기">2 단계: 데이터 가져오기</h3>
<p>만약 2개 혹은 3개 국가에 대한 데이터만 살펴본다면, 하나씩 파일을 다운로드하기만 하면 된다. 하지만, 다른 많은 나라에 데이터를 비교하고자 한다면 프로그램을 작성해야 한다.</p>
<p>파이썬에는 URL 작업을 위한 <code>urllib2</code> 라이브러리가 있지만, 사용하기가 좀 투박하다. 그래서 많은 사람들은 <a href="http://docs.python-requests.org/en/latest/">Requests</a>라는 써드파티 라이브러리를 선호한다. 설치하기 위해서 다음 명령어를 실행한다.</p>
<pre><code>!pip install requests

Requirement already satisfied (use --upgrade to upgrade): requests in c:\python\user\lib\site-packages
Cleaning up...</code></pre>
<p>(이미 설치를 했기 때문에 상기 메시지가 나온다; 만약 설치하지 않았다면, 다른 메시지가 나올 것이다.) 이제 다음과 같이 데이터를 불러올 수 있다.</p>
<pre><code>import requests
url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv&#39;
response = requests.get(url)
if response.status_code != 200:
    print &#39;Failed to get data:&#39;, response.status_code
else:
    print &#39;First 100 characters of data are&#39;
    print response.text[:100]

First 100 characters of data are
year,data
1901,-7.67241907119751
1902,-7.862711429595947
1903,-7.910782814025879
1904,-8.15572929382</code></pre>
<p>프로그램 첫번째 행은 <code>requests</code> 라이브러리를 가져온다. 두번째 행은 가져올 데이터 URL을 정의한다; 세번째 행에 <code>requests.get</code> 호출에 인자로 URL을 넘길 수도 있지만, 변수로 대입하는 것이 찾기가 더 쉽다.</p>
<p>사실 <code>requests.get</code>이 데이터를 가져온다. 좀더 구체적으로 살펴보면:</p>
<ol style="list-style-type: decimal">
<li><code>climatedataapi.worldbank.org</code> 서버에 연결을 생성한다;</li>
<li>서버에 URL로 <code>/climateweb/rest/v1/country/cru/tas/year/CAN.csv</code>을 전송한다;</li>
<li>서버 응답결과를 담기 위해서 사용자 컴퓨터 메모리에 객체를 생성한다;</li>
<li>요청결과가 성공했는지 아닌지를 식별하기 위해서 객체의 <code>status_code</code> 멤버 변수에 숫자를 할당한다.</li>
<li>웹서버에서 전송받은 데이터를 객체 <code>text</code> 멤버 변수에 할당한다.</li>
</ol>
<p>서버는 다른 많은 <a href="../../gloss.html#http-status-code">상태 코드(status codes)</a>를 반환할 수 있다; 가장 일반적인 것은 다음과 같다:</p>
<table>
<tr>
<td>
200
</td>
<td>
성공(OK)
</td>
<td>
요청 성공.
</td>
</tr>
<tr>
<td>
204
</td>
<td>
콘텐츠 없음(No Content)
</td>
<td>
서버가 요청을 수행했지만, 어떤 데이터도 반환할 필요가 없다.
</td>
</tr>
<tr>
<td>
400
</td>
<td>
잘못된 요청(Bad Request)
</td>
<td>
서버가 요청의 구문을 인식하지 못했다.
</td>
</tr>
<tr>
<td>
401
</td>
<td>
권한없음(Unauthorized)
</td>
<td>
이 요청은 인증이 필요하다.
</td>
</tr>
<tr>
<td>
404
</td>
<td>
찾을 수 없음(Not Found)
</td>
<td>
서버가 요청한 페이지를 찾을 수 없다.
</td>
</tr>
<tr>
<td>
408
</td>
<td>
요청 시간초과(Timeout)
</td>
<td>
서버의 요청 대기가 시간을 초과하였다.
</td>
</tr>
<tr>
<td>
418
</td>
<td>
I’m a teapot
</td>
<td>
No, really…
</td>
</tr>
<tr>
<td>
500
</td>
<td>
내부 서버 오류(Internal Server Error)
</td>
<td>
서버에 오류가 발생하여 요청을 수행할 수 없다.
</td>
</tr>
</table>
<p>상기 상태코드 중에서 정말 신경쓸 것은 단하나 200다; 만약 다른 것을 보게 된다면, 응답은 아마도 실제 데이터를 포함하고 있지 않는다. (오류 메시지를 포함할 수도 있지만)</p>
<blockquote>
<h4>몇몇 사람들은 규칙을 지키지 않는다.</h4>
<p>불행하게도, 몇몇 사이트는 유의미한 상태코드를 반환하지 않는다. 대신에 <em>모두</em> 200를 반환하고, 응답 텍스트에 오류 메시지를 넣는다. 결과가 사람에게 보여진다면 의미가 있지만, 실질적으로 읽을 수 없는 프로그램이 “읽게”된다면 프로그램이 중단된다.</p>
</blockquote>
<h4 id="도전-과제-1">도전 과제</h4>
<ol style="list-style-type: decimal">
<li>상기 프로그램 URL을 변경해서, 존재하지 않는 국가코드를 데이터로 전달해서 상태코드가 어떻게 되는지 살펴보세요.</li>
</ol>
<h3 id="단계-데이터-파싱">3 단계: 데이터 파싱</h3>
<p>앞에서 작성한 작은 프로그램이 원하는 데이터를 물어다준다. 하지만, 숫자 리스트보다는 한줄 긴 문자열로 반환한다. 긴 문자열을 숫자 리스트로 변환하는 방법이 두가지 있다.</p>
<ol style="list-style-type: decimal">
<li>함수를 작성해서 개행문자로 문자열을 쪼개서 행을 생성하고 나서, 콤마로 행을 다시 쪼개고 나서, 마지막으로 콤마로 구분된 각 부분을 숫자로 변환한다.</li>
<li>사용자를 위해서 상기 작업을 해주는 파이썬 라이브러리를 사용한다.</li>
</ol>
<p>대부분 경험 많은 프로그래머는 두번째 접근법이 더 쉽다고 말하지만, “쉽다”는 것은 상대적이다: 만약 라이브러리가 존재한다는 것을 인지하고, 충분히 알고 있어서, 라이브러리가 수행하는 것으로 문제를 해결하는 방식을 알고 있다면, 표준 라이브러리를 사용하는 것이 실무에서 좀더 효과적이 된다.</p>
<p>두가지 방식을 함께 시도해 보자. 첫번째 방식으로 작성하는 작은 프로그램이 다음에 있다.</p>
<pre><code>input_data = &#39;&#39;&#39;1901,12.3
1902,45.6
1903,78.9&#39;&#39;&#39;

as_lines = input_data.split(&#39;\n&#39;)
print &#39;input data as lines:&#39;
print as_lines

for line in as_lines:
    fields = line.split(&#39;,&#39;) # turn &#39;1901,12.3&#39; into [&#39;1901&#39;, &#39;12.3&#39;]
    year = int(fields[0])    # turn the text &#39;1901&#39; into the integer 1901
    value = float(fields[1]) # turn the text &#39;12.3&#39; into the number 12.3
    print year, &#39;:&#39;, value

input data as lines:
[&#39;1901,12.3&#39;, &#39;1902,45.6&#39;, &#39;1903,78.9&#39;]
1901 : 12.3
1902 : 45.6
1903 : 78.9</code></pre>
<p>입력 데이터로 사용될 문자열을 정의하면서 프로그램을 시작한다. 그렇게 함으로서 출력결과의 정합성을 담보할 수 있다. 첫 3줄 코드는 개행문자(프로그램에서 <code>\n</code>을 사용)로 쪼개서 한 다중행 문자열을 문자열 리스트로 변환한다. 그리고 나서, <code>for</code> 루프가 콤마로 행을 쪼개고 숫자로 변환해서 각 행에서 연도(year)와 값(value)을 추출한다.</p>
<blockquote>
<h4>이스케이프 시퀀스(Escape Sequences)</h4>
<p>문자열에 인용부호, 이중 인용부호, 그리고 다른 특수 문자를 표현할 방법이 필요하다. 이를 위해서 <a href="../../gloss.html#escape-sequence">이스케이프 시퀀스(escape sequences)</a>를 사용한다. <code>\'</code>는 단일 인용부호, <code>\&quot;</code>는 이중 인용부호, <code>\n</code>는 개행문자. 등등</p>
<pre><code>&#39;This can\&#39;t be\nwritten without\n\&quot;escape sequences\&quot;.&#39; 이 의미하는 바는 다음과 같다.</code></pre>
<p>출력은 다음과 같다. <sub>~</sub> This can’t be written without “escape sequences”. <sub>~</sub></p>
</blockquote>
<p>이제 몇몇 표준 파이썬 라이브러리를 통해서 데이터를 파싱하는 방법을 살펴보자. 첫번째 라이브러리(<code>cStringIO</code>)는 문자열을 마치 입력파일처럼 처리한다.</p>
<pre><code>import cStringIO

data = &#39;&#39;&#39;first
second
third&#39;&#39;&#39;

reader = cStringIO.StringIO(data)
for line in reader:
    print line

first

second

third</code></pre>
<p><code>reader</code>에 대입하는 <code>cStringIO.StringIO</code> 객체는 파일처럼 동작하는 객체다. 하지만 하드 드라이브에서 무언가를 읽는 대신에 문자열로부터 문자를 읽어온다. 연습문제에서 보듯이, <code>StringIO</code> 객체에 쓸 수도 있어서, 프로그램을 테스트할 때 매우 유용하다.</p>
<blockquote>
<h3>왜 ‘c’ 일까?</h3>
<p><code>cStringIO</code> 맨처음의 ’c’는 C언어로 작성된 다소 오래되고 속도가 늦은 <code>StringIO</code> 라이브러리를 다시 작성한 것에 기인한다.</p>
</blockquote>
<p>두번재 라이브러리로 <code>csv</code>을 사용한다. <code>csv</code> 라이브러리는 그 자체로 데이터를 읽어들이지 않는다: 대신에, 무언가로 읽어온 행을 받고서, 콤마로 쪼개고 리스트 값으로 변환한다.</p>
<pre><code>import csv

data = &#39;&#39;&#39;first,FIRST
second,SECOND
third,THIRD&#39;&#39;&#39;
reader = cStringIO.StringIO(data)
wrapper = csv.reader(reader)
for record in wrapper:
    print record

[&#39;first&#39;, &#39;FIRST&#39;]
[&#39;second&#39;, &#39;SECOND&#39;]
[&#39;third&#39;, &#39;THIRD&#39;]</code></pre>
<p>지금까지 작업한 것을 조합하면, 다음과 같이 Canada에 대한 데이터를 얻을 수 있다.</p>
<pre><code>url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv&#39;
response = requests.get(url)
if response.status_code != 200:
    print &#39;Failed to get data:&#39;, response.status_code
else:
    reader = cStringIO.StringIO(response.text)
    wrapper = csv.reader(reader)
    for record in wrapper:
        year = int(record[0])
        value = float(record[1])
        print year, &#39;:&#39;, value


---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)

&lt;ipython-input-6-da21db395042&gt; in &lt;module&gt;()
      7     wrapper = csv.reader(reader)
      8     for record in wrapper:
----&gt; 9         year = int(record[0])
     10         value = float(record[1])
     11         print year, &#39;:&#39;, value


ValueError: invalid literal for int() with base 10: &#39;year&#39;</code></pre>
<p>데이터의 첫번째 줄 때문에 오류가 발생했다:</p>
<pre><code>year,data</code></pre>
<p>문자열 <code>'year'</code>을 정수형으로 변환할 때, 파이썬이 바로 항의한다. 오류수정은 복잡하지 않다: 단어 <code>year</code>로 시작하는 행을 무시하고 넘어간다. 그리고, 결과를 얻었을 때, 화면에 출력하는 대신에 리스트에 결과를 넣는다.</p>
<pre><code>import requests
import cStringIO
import csv
url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/CAN.csv&#39;
response = requests.get(url)
if response.status_code != 200:
    print &#39;Failed to get data:&#39;, response.status_code
else:
    reader = cStringIO.StringIO(response.text)
    wrapper = csv.reader(reader)
    results = []
    for record in wrapper:
        if record[0] != &#39;year&#39;:
            year = int(record[0])
            value = float(record[1])
            results.append([year, value])
    print &#39;first five results&#39;
    print results[:5]

first five results
[[1901, -7.67241907119751], [1902, -7.862711429595947], [1903, -7.910782814025879], [1904, -8.155729293823242], [1905, -7.547311305999756]]</code></pre>
<h4 id="도전과제">도전과제</h4>
<ol style="list-style-type: decimal">
<li><code>StringIO</code>를 출력에도 사용할 수 있다. 이것을 사용해서 <code>print_count</code> 함수가 올바로 작동하는 테스트 함수를 작성하세요. <sub>~</sub> def print_count(output, num): for i in range(num): print &gt;&gt; output, num <sub>~</sub></li>
</ol>
<h3 id="단계-재사용가능한-함수-작성하기">4 단계: 재사용가능한 함수 작성하기</h3>
<p>캐나다에 대한 데이터를 얻는 방법을 이제 알게되었으니, 임의 나라에 대해서 동일한 작업을 수행하는 함수를 작성하자. 단계는 단순하다: 작성한 코드를 복사해서 매개변수로 3-문자 국가코드를 받아서 적당한 곳에 URL에 국가코드를 삽입하는 함수를 작성한다.</p>
<pre><code>def get_annual_mean_temp_by_country(country):
    &#39;&#39;&#39;Get the annual mean temperature for a country given its 3-letter ISO code (such as &quot;CAN&quot;).&#39;&#39;&#39;
    url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/&#39; + country + &#39;.csv&#39;
    response = requests.get(url)
    if response.status_code != 200:
        print &#39;Failed to get data:&#39;, response.status_code
    else:
        reader = cStringIO.StringIO(response.text)
        wrapper = csv.reader(reader)
        results = []
        for record in wrapper:
            if record[0] != &#39;year&#39;:
                year = int(record[0])
                value = float(record[1])
                results.append([year, value])
        return results</code></pre>
<p>다음과 같이 동작한다.</p>
<pre><code>canada = get_annual_mean_temp_by_country(&#39;CAN&#39;)
print &#39;first five entries for Canada:&#39;, canada[:5]

first five entries for Canada: [[1901, -7.67241907119751], [1902, -7.862711429595947], [1903, -7.910782814025879], [1904, -8.155729293823242], [1905, -7.547311305999756]]</code></pre>
<p>하지만 문제가 있다. 유효하지 않는 국가 식별자를 매개변수로 전달할 때 무슨일이 발생하는지 살펴보자.</p>
<pre><code>latveria = get_annual_mean_temp_by_country(&#39;LTV&#39;)
print &#39;first five entries for Latveria:&#39;, latveria[:5]

first five entries for Latveria: []</code></pre>
<p>Latveria는 존재하지 않는다. 그래서 왜 작성한 함수는 오류 메시지를 출력하는 대신에 빈 리스트를 반환할까? 오류 메시지가 없다는 의미는 응답코드가 200을 의미한다: 만약 그렇다면, <code>else</code> 브랜치로 가서 <code>result</code>에 빈 리스트를 대입하고 그리고… 흠… 좋아… 만약 응답코드가 200 이고 데이터가 없다면, 그 자체가 사용자가 보는 것을 설명한다.</p>
<blockquote>
<h4>편집(Editing) vs. 복사(Copying)</h4>
<p>실제 자료분석에서 사용하려고 함수를 작성하고 있다면, 다시 돌아가서 그 위치에서 변경한다. 오류 버젼과 수정버젼을 함께 보여주기 위해서 대신에 함수를 복사했다.</p>
</blockquote>
<pre><code>def get_annual_mean_temp_by_country(country):
    &#39;&#39;&#39;Get the annual mean temperature for a country given its 3-letter ISO code (such as &quot;CAN&quot;).&#39;&#39;&#39;
    url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/&#39; + country + &#39;.csv&#39;
    print &#39;url used is&#39;, url
    response = requests.get(url)
    print &#39;response code:&#39;, response.status_code
    print &#39;length of data:&#39;, len(response.text)
    if response.status_code != 200:
        print &#39;Failed to get data:&#39;, response.status_code
    else:
        reader = cStringIO.StringIO(response.text)
        wrapper = csv.reader(reader)
        results = []
        for record in wrapper:
            if record[0] != &#39;year&#39;:
                year = int(record[0])
                value = float(record[1])
                results.append([year, value])
        return results

latveria = get_annual_mean_temp_by_country(&#39;LTV&#39;)
print &#39;number of records for Latveria:&#39;, len(latveria)

url used is http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/LTV.csv
response code: 200
length of data: 0
number of records for Latveria: 0</code></pre>
<p>훌륭해: 약간 더 실험한 후에, 세계은행 사이트는 <em>항상</em> 200 상태 코드를 반환하는 것을 발견했다. 실제 데이터가 있는지 없는지를 알 수 있는 유일한 방식은 <code>response.text</code>가 비었는지(empty) 점검하는 것이다. 다음에 갱신된 함수가 있다.</p>
<pre><code>def get_annual_mean_temp_by_country(country):
    &#39;&#39;&#39;
    Get the annual mean temperature for a country given its 3-letter ISO code (such as &quot;CAN&quot;).
    Returns an empty list if the country code is invalid.
    &#39;&#39;&#39;
    url = &#39;http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/&#39; + country + &#39;.csv&#39;
    response = requests.get(url)
    results = []
    if len(response.text) &gt; 0:
        reader = cStringIO.StringIO(response.text)
        wrapper = csv.reader(reader)
        for record in wrapper:
            if record[0] != &#39;year&#39;:
                year = int(record[0])
                value = float(record[1])
                results.append([year, value])
    return results

print &#39;number of records for Canada:&#39;, len(get_annual_mean_temp_by_country(&#39;CAN&#39;))
print &#39;number of records for Latveria:&#39;, len(get_annual_mean_temp_by_country(&#39;LTV&#39;))

number of records for Canada: 112
number of records for Latveria: 0</code></pre>
<h4 id="도전-과제-2">도전 과제</h4>
<ol style="list-style-type: decimal">
<li>다운로드 받을 데이터가 없을 때, 함수는 오류 메시지를 출력해야할까요? 왜 혹은 왜 그렇지 않을까요?</li>
</ol>
<h3 id="단계-국가-비교하기">5 단계: 국가 비교하기</h3>
<p>다른 국가에 대한 지상 기온을 얻을 수 있기 때문에, 국가 온도를 비교하는 함수를 작성할 수 있다. (이제 궁극적으로 작업하려는 것에 대해 명확해졌기 때문에, 바로 함수를 작성한다.) 다음에 작성한 첫번째 함수가 있다.</p>
<pre><code>def diff_records(left, right):
    &#39;&#39;&#39;Given lists of [year, value] pairs, return list of [year, difference] pairs.&#39;&#39;&#39;
    num_years = len(left)
    results = []
    for i in range(num_years):
        left_year, left_value = left[i]
        right_year, right_value = right[i]
        difference = left_value - right_value
        results.append([left_year, difference])
    return results</code></pre>
<p>여기서 루프 제어를 위해서 <code>left</code>에 항목 숫자를 사용한다. (항목숫자는 <code>len(left)</code>로 알 수 있다.)</p>
<p>다음 표현식</p>
<pre><code>for i in range(num_years):</code></pre>
<p>0부터 <code>num_years-1</code>까지 <code>i</code>를 실행한다. 정확하게 <code>left</code> 인덱스와 상응한다. 루프 내부에서 리스트 항목에서 왼쪽, 오른쪽 년도와 값을 풀어서 년도와 차이값을 <code>results</code>에 추가한다. 그리고 마지막에 결과를 반환한다.</p>
<p>작성한 함수가 동작하는지 살펴보기 위해서, 몇개 테스트 데이터를 작성해서 실행한다.</p>
<pre><code>print &#39;one record:&#39;, diff_records([[1900, 1.0]],
                                  [[1900, 2.0]])
print &#39;two records:&#39;, diff_records([[1900, 1.0], [1901, 10.0]],
                                   [[1900, 2.0], [1901, 20.0]])

one record: [[1900, -1.0]]
two records: [[1900, -1.0], [1901, -10.0]]</code></pre>
<p>매우 좋아 보인다— 하지만, 다음 테스트 케이스는 어떨까?</p>
<pre><code>print &#39;mis-matched years:&#39;, diff_records([[1900, 1.0]],
                                         [[1999, 2.0]])
print &#39;left is shorter&#39;, diff_records([[1900, 1.0]],
                                      [[1900, 10.0], [1901, 20.0]])
print &#39;right is shorter&#39;, diff_records([[1900, 1.0], [1901, 2.0]],
                                       [[1900, 10.0]])


---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)

&lt;ipython-input-15-7582f56db8bf&gt; in &lt;module&gt;()
      4                                       [[1900, 10.0], [1901, 20.0]])
      5 print &#39;right is shorter&#39;, diff_records([[1900, 1.0], [1901, 2.0]],
----&gt; 6                                        [[1900, 10.0]])


&lt;ipython-input-13-67464343fd99&gt; in diff_records(left, right)
      5     for i in range(num_years):
      6         left_year, left_value = left[i]
----&gt; 7         right_year, right_value = right[i]
      8         difference = left_value - right_value
      9         results.append([left_year, difference])


IndexError: list index out of range


mis-matched years: [[1900, -1.0]]
left is shorter [[1900, -9.0]]
right is shorter</code></pre>
<p>설사 년도가 매칭되지 않지만, 첫번째 테스트는 답을 제시한다: 결과값을 얻었지만, 무의미하다. 두번째 테스트 케이스는 부분적인 결과를 제시한다. 이번에도 문제가 있다고 보고하지는 않는다. 하지만, 세번째는 프로그램이 중단된다. 왜냐하면 레코드 숫자를 결정하는데 <code>left</code>를 사용하지만, <code>right</code>는 그만큼의 숫자를 가지고 있지 않기 때문이다.</p>
<p>첫 두 문제는 세번째 것보다 사실 더 나쁘다. 왜냐하면 첫 두 문제가 <a href="../../gloss.html#silent-failure">침묵하는 실패(silent failures)</a>이기 때문이다: 함수가 잘못된 것을 수행하지만, 어떤 방식으로도 나타내지 않는다. 버그를 수정해보자:</p>
<pre><code>def diff_records(left, right):
    &#39;&#39;&#39;
    Given lists of [year, value] pairs, return list of [year, difference] pairs.
    Fails if the inputs are not for exactly corresponding years.
    &#39;&#39;&#39;
    assert len(left) == len(right), \
           &#39;Inputs have different lengths.&#39;
    num_years = len(left)
    results = []
    for i in range(num_years):
        left_year, left_value = left[i]
        right_year, right_value = right[i]
        assert left_year == right_year, \
               &#39;Record {0} is for different years: {1} vs {2}&#39;.format(i, left_year, right_year)
        difference = left_value - right_value
        results.append([left_year, difference])
    return results</code></pre>
<p>“착한” 테스트 케이스는 통과했나요?</p>
<pre><code>print &#39;one record:&#39;, diff_records([[1900, 1.0]],
                                  [[1900, 2.0]])
print &#39;two records:&#39;, diff_records([[1900, 1.0], [1901, 10.0]],
                                   [[1900, 2.0], [1901, 20.0]])

one record: [[1900, -1.0]]
two records: [[1900, -1.0], [1901, -10.0]]</code></pre>
<p>이제 실패가 예상되는 세가지 테스트 케이스는 어떤가요?</p>
<pre><code>print &#39;mis-matched years:&#39;, diff_records([[1900, 1.0]],
                                         [[1999, 2.0]])


---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)

&lt;ipython-input-18-c101917a748e&gt; in &lt;module&gt;()
      1 print &#39;mis-matched years:&#39;, diff_records([[1900, 1.0]],
----&gt; 2                                          [[1999, 2.0]])


&lt;ipython-input-16-d41327791c15&gt; in diff_records(left, right)
     10         left_year, left_value = left[i]
     11         right_year, right_value = right[i]
---&gt; 12         assert left_year == right_year,                &#39;Record {0} is for different years: {1} vs {2}&#39;.format(i, left_year, right_year)
     13         difference = left_value - right_value
     14         results.append([left_year, difference])


AssertionError: Record 0 is for different years: 1900 vs 1999


mis-matched years:


print &#39;left is shorter&#39;, diff_records([[1900, 1.0]],
                                      [[1900, 10.0], [1901, 20.0]])


---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)

&lt;ipython-input-19-682d448d921e&gt; in &lt;module&gt;()
      1 print &#39;left is shorter&#39;, diff_records([[1900, 1.0]],
----&gt; 2                                       [[1900, 10.0], [1901, 20.0]])


&lt;ipython-input-16-d41327791c15&gt; in diff_records(left, right)
      4     Fails if the inputs are not for exactly corresponding years.
      5     &#39;&#39;&#39;
----&gt; 6     assert len(left) == len(right),            &#39;Inputs have different lengths.&#39;
      7     num_years = len(left)
      8     results = []


AssertionError: Inputs have different lengths.


 left is shorter


print &#39;right is shorter&#39;, diff_records([[1900, 1.0], [1901, 2.0]],
                                       [[1900, 10.0]])


---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)

&lt;ipython-input-20-a475e608dd70&gt; in &lt;module&gt;()
      1 print &#39;right is shorter&#39;, diff_records([[1900, 1.0], [1901, 2.0]],
----&gt; 2                                        [[1900, 10.0]])


&lt;ipython-input-16-d41327791c15&gt; in diff_records(left, right)
      4     Fails if the inputs are not for exactly corresponding years.
      5     &#39;&#39;&#39;
----&gt; 6     assert len(left) == len(right),            &#39;Inputs have different lengths.&#39;
      7     num_years = len(left)
      8     results = []


AssertionError: Inputs have different lengths.


 right is shorter</code></pre>
<p>정말 훌륭해요: 만약 형식이 올바르지 않거나 부합하지 않는 데이터를 처리하려고 한다면, 추가한 가정대입문이 이제 경고를 보낸다.</p>
<blockquote>
<h4>더 좋은 방법이 있다.</h4>
<p>프로그램 셀 내부에서 각 테스트를 실행해야만 한다. 왜냐하면, 가정대입문이 실패하자마자 코드 실행을 파이썬이 멈추기 때문이고, 테스트 3개가 모두 실질적으로 실행되도록 확실히 하고자 한다. <a href="../../gloss.html#unit-testing">단위 테스트 (unit testing)</a> 라이브러리가 사용자를 대신해서 처리하고, 또한 그밖의 더 많은 것도 수행한다; 파이썬 중급과정에서 단위 테스트 라이브러리를 다룬다.</p>
</blockquote>
<h4 id="도전-과제-3">도전 과제</h4>
<ol style="list-style-type: decimal">
<li><p>데이터를 다운로드 받지 못할 경우, <code>get_annual_mean_temp_by_country</code> 함수는 가정대입문을 사용해야 할까? 왜 혹은 왜 그렇지 않을까?</p></li>
<li><p><code>for</code>에서 종종 사용되는 <code>enumerate</code>라는 함수가 파이썬에 포함되어 있다. 다음 루프는 <sub>~</sub> for (i, c) in enumerate(‘abc’): print i, ‘=’, c <sub>~</sub> 아래와 같이 출력한다. <sub>~</sub> 0 = a 1 = b 2 = c <sub>~</sub> <code>enumerate</code>를 사용해서 <code>diff_records</code>를 재작성하세요.</p></li>
</ol>
<h3 id="단계-모두-함께-놓아보자">6 단계: 모두 함께 놓아보자</h3>
<p>이제 국가별로 기온차이를 시각화하는데 필요한 모든 도구를 갖게 되었다.</p>
<pre><code>%matplotlib inline

from matplotlib import pyplot as plt

australia = get_annual_mean_temp_by_country(&#39;AUS&#39;)
canada = get_annual_mean_temp_by_country(&#39;CAN&#39;)
diff = diff_records(australia, canada)
plt.plot(diff)
plt.show()</code></pre>
<div class="figure">
<img src="01-getdata_files/intermediate/webdata/01-getdata_55_0.png" alt="png" /><p class="caption">png</p>
</div>
<p>이것은 원하는 바가 아니다: 라이브러리가 리스트 짝을 하나의 곡선에 대한 (x,y) 좌표라기 보다는 두개 상응하는 곡선으로 해석했다. (year, difference) 리스트 짝을 NumPy 배열로 변환하자.</p>
<pre><code>import numpy as np
d = np.array(diff)</code></pre>
<p>그리고 나서, 두번째 칼럼에 첫번째 칼럼을 플롯(plot)한다.</p>
<pre><code>plt.plot(d[:, 0], d[:, 1])
plt.show()</code></pre>
<div class="figure">
<img src="01-getdata_files/intermediate/webdata/01-getdata_59_0.png" alt="png" /><p class="caption">png</p>
</div>
<p>차이(difference)가 천천히 줄어드는 것처럼 보이지만, 신호(signal)에 잡음(noise)이 많다. 이 지점에서, 만약 실질적 해답을 구한다면, 곡선맞춤(curve-fitting) 라이브러리를 열어볼 시점이다.</p>
<h4 id="도전-과제-4">도전 과제</h4>
<ol style="list-style-type: decimal">
<li>플롯(plot) 명령어를 변경해서 Y축 스케일을 0에서 32로 바꾼다. 이렇게 스케일을 변경하는 것이 데이터에 대한 좀더 정확한 혹은 덜 정확한 시점을 준다고 생각합니까?</li>
</ol>
<h4 id="주요점">주요점</h4>
<ul>
<li>많은 인터넷 사이트는 특정 방식으로 데이터를 가공해서 URL을 통해서 다운로드할 수 있도록 데이터를 공개한다.</li>
<li><code>requests</code> 라이브러리를 사용해서 파이썬 프로그램에서 데이터를 다운로드한다.</li>
<li><code>cStringIO</code> 라이브러리를 사용해서 텍스트를 입력 혹은 출력 파일로 다룰 수 있다.</li>
<li><code>csv</code> 라이브러리를 사용해서 콤마 구분 값(comma-separated values)을 읽어온다.</li>
<li>테스트를 작성한다.</li>
</ul>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="http://xwmooc.net">xwMOOC</a>
        <a class="label swc-blue-bg" href="https://github.com/statkclee/swcarpentry-version-5-3-new">한글소스</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry">영문소스</a>
        <a class="label swc-blue-bg" href="mailto:i@xwmooc.net">Contact</a>
        <a class="label swc-blue-bg" href="http://statkclee.github.io/swcarpentry-version-5-3-new/LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
  </body>
</html>
